#!/usr/bin/perl -w
#!/usr/bin/perl -w -d:ptkdb
#


use strict;


BEGIN
{
    #! make check

    push @INC, '../perl';

    #! make distcheck

    push @INC, '../../perl';

    #! normal run

    push @INC, './perl';

    #! after install

    push @INC, '/usr/local/glue/swig/perl';
}


use Getopt::Long;

use Neurospaces::Documentation;

use YAML;


$SIG{__DIE__}
    = sub {

	Neurospaces::Documentation::Publications::publish_production_results();

	use Carp;

	confess @_;
    };


$SIG{INT}
    = sub {
	use Carp;

	confess @_;

	exit 1;
    };


$0 =~ m(.*/(.*));

my $program_name = $1;

$program_name =~ m((.*?)[_-](.*));

my $documentation_set_name = $1;
my $root_operation_name = $2;

my $home_page_document = "${documentation_set_name}-homepage";

my $output_filename = "${documentation_set_name}_cron.out";
my $descriptor_check = "";
my $build_directory = "$ENV{HOME}/neurospaces_project/${documentation_set_name}/source/snapshots/0";
my $htaccess_file = "";

#
# options
#

my $option_output_directory = "/tmp";
my $option_config = "";
my $option_html_output_directory = "$ENV{HOME}/public_html";

my $configuration
    = {
      };


sub main
{
    {
	my $result
	    = GetOptions
		(
		 "config=s" => \$option_config,
		 "outputdir=s" => \$option_output_directory,
		);

    }

    if ($option_config)
    {
	parse_config_file($option_config);
    }

    my $output_path = $option_output_directory . "/" . $output_filename;

    rotate_logs();

    # create empty output file

    try_to("echo > $output_path",1);

    $ENV{PATH} .= ':/bin:/usr/bin:/usr/local/bin';

    # upgrade the developer package

    try_to("neurospaces_pull --regex developer",1); 

    try_to("neurospaces_update --regex developer",1); 

    try_to("neurospaces_configure --regex developer",1);

    try_to("neurospaces_install --regex developer",1);

    # upgrade the content-framework package

    try_to("neurospaces_pull --regex content-framework",1); 

    try_to("neurospaces_update --regex content-framework",1); 

    try_to("neurospaces_configure --regex content-framework",1);

    try_to("neurospaces_install --regex content-framework",1);

    try_to("neurospaces_clean --regex content-framework",1);

    # upgrade the content itself

    try_to("neurospaces_pull --regex ${documentation_set_name}",1); 

    try_to("neurospaces_update --regex ${documentation_set_name}",1); 

    try_to("neurospaces_configure --regex ${documentation_set_name}",1);

    try_to("neurospaces_install --regex ${documentation_set_name}",1);

    try_to("neurospaces_clean --regex ${documentation_set_name}",1);

    #   try_to("${documentation_set_name}-check > $output_path",1);

    # collect the descriptor check info for the email

    $descriptor_check = `${documentation_set_name}-check --directory $build_directory`;

    try_to("make website-prepare -C ~/neurospaces_project/${documentation_set_name}/source/snapshots/0/ >> $output_path",1);

    # do a link check.

    my $webcheck_path = `which webcheck`;

    if ($webcheck_path ne "")
    {
	try_to("make webcheck -C ~/neurospaces_project/${documentation_set_name}/source/snapshots/0/ >> $output_path",1);
    }

    copy_html_data();

    contents_page_generate();

    index_page_generate();

    if ($htaccess_file ne "")
    {
	copy_htacces_file();
    }

    my $text = produce_email_text();

    try_to_mail("${documentation_set_name} cron has finished.",
		"${documentation_set_name} has finished building.\n\n" . $text);
}


sub produce_email_text
{
    my $status_message = "";

    my $outputfile = $option_output_directory . "/" . $output_filename;

    my $die_messages = `grep die $outputfile`;

    $status_message
	.= (
	    "$0:\nCheck for your output on the host machine here "
	    . $option_output_directory
	    . "/"
	    . $output_filename . "\n"
	   );

    if (defined $configuration->{URL})
    {
	$status_message .= "Check the output over the web via this link " . $configuration->{URL} . "\n";
    }

#     my $url = $option_html_output_directory . "/${documentation_set_name}/contents.html";

#     $status_message .= "Check the output over the web via this link " . $url . "\n";

    # add the publication report produced during the build

    use IO::File;

    my $publication_report_file = IO::File->new("</tmp/all_publication_results");

    if ($publication_report_file)
    {
	local $/;

	my $publication_report = <$publication_report_file>;

	$status_message .= "\n" . $publication_report . "\n";
    }
    else
    {
	$status_message .= "\nunable to read a publication report (error opening /tmp/all_publication_results\n\n";
    }

    if ($descriptor_check ne "")
    {
	$status_message .= "\nDescriptor file check:\n" .$descriptor_check . "\n\n";
    }

    # find all of the log files and check for error messages

    my $errors = "";

    my $logfiletext = `find ~/neurospaces_project/${documentation_set_name}/source/snapshots/0 | grep output | grep html | grep \.log`;

    my @logfiles = split(/\n/,$logfiletext);

    my $logfile;

    foreach $logfile (@logfiles)
    {
	my $latexerrors = `cat $logfile | grep ^!`;

	if ($latexerrors eq "")
	{
	    next;
	}
	else
	{
	    #my $filename = $logfile;
	    #$filename =~ m(.*output/(.*)\.log$);
	    my @tmp = split(/\//,$logfile);
	    my $tmp = $tmp[-1];
	    @tmp = split(/\./,$tmp);
	    my $filename = $tmp[0];

	    $status_message .= "\n\n";

	    $status_message .= "Error in document: ";

	    $status_message .= $filename;

	    $status_message .= " : \n\t";

	    $status_message .= $latexerrors;
	}
    }

    return $status_message;
}


sub try_to_mail
{
    my $subject = shift;
    my $message = shift;

    if (!$configuration->{MAILTO})
    {
	print "No addressee indicated in configuration\n";
	return;
    }

    my $sendto = $configuration->{MAILTO};
    my $replyto = $configuration->{MAILFROM};

    open(MAIL, "|/usr/sbin/sendmail -oi -t");
    print MAIL "From: $replyto\n";
    print MAIL "To: $sendto\n";
    print MAIL "Subject: $subject\n\n";
    print MAIL "$message\n";
    close(MAIL);
}


#
# ("command", verbosity_level)
#

sub try_to
{
    my $command = shift;

    my $no_verbose = shift;

    my $allow_fail = shift;

    if (!$no_verbose)
    {
	print "---\n";
	print "$0: trying to $command\n";
    }

    my $output_path = $option_output_directory . "/" . $output_filename;

    #! $command executed in a subshell such that redirection applies
    #! to all commands.

    system "( $command ) >>$output_path 2>&1";

    if ($?)
    {
	if ($allow_fail)
	{
	    system "echo >>$output_path 2>&1 failed with $?: $command\n";
	}
	else
	{
	    report_error($command, $?);
	}
    }
}





sub report_error
{
    my $command = shift;

    my $error_code = shift;

    my $message = "$0: $command returned $error_code";

    if($descriptor_check ne "")
    {
      $message .= "\nDescriptor file check:\n" .$descriptor_check . "\n\n";
    }

    try_to_mail("${0}_cron error", $message);

    die "$0: $command returned $error_code";
}


#
# copies the resulting html data to a directory specified in
# the config file and then sets up a sym link for it.
#
# It copies over the html data into a directory, then symlinks
# to that directory.
#
# operations are similar to:
#   cp userdocs_data html_dir/userdocs_data
#   ln -s html_dir/userdocs_data html_dir/userdocs
#
sub copy_html_data
{
    my $html_symlink = $option_html_output_directory . "/" . "${documentation_set_name}";
    my $html_data_directory = $option_html_output_directory . "/" . "${documentation_set_name}_data";
    my $html_build_directory = "~/neurospaces_project/${documentation_set_name}/source/snapshots/0/html/htdocs/neurospaces_project/${documentation_set_name}/";

    try_to("mkdir --parents $option_html_output_directory");

    try_to("rm -rf $html_data_directory");
    try_to("cp -rf $html_build_directory $html_data_directory",1);
    try_to("rm -f $html_symlink",1);
    try_to("ln -s $html_data_directory $html_symlink",1);
}


#
# ($config_file) a file with a configuration in it.
#
sub parse_config_file
{
    my $config_file = shift;

    if (!-e $config_file)
    {
	print "\n$config_file is an invalid filename\n";

	return;
    }

    print "\nParsing configuration in $config_file\n\n";

    $configuration = YAML::LoadFile($config_file);

    if (!defined $configuration)
    {
	print "This YAML file is invalid\n";

	return;
    }

    if (defined $configuration->{MAILTO})
    {
	chomp($configuration->{MAILTO});

	print "\tSend to email: $configuration->{MAILTO}\n";
    }

    if (defined $configuration->{MAILFROM})
    {
	chomp($configuration->{MAILFROM});

	print "\tSend from email: $configuration->{MAILFROM}\n";
    }

    if (defined $configuration->{HTMLDIR})
    {
	$option_html_output_directory = $configuration->{HTMLDIR};

	chomp($configuration->{HTMLDIR});

	print "\tThe directory for html output is: $configuration->{HTMLDIR}\n";
    }

    if (defined $configuration->{OUTPUTDIR})
    {
	#! note that this overrides an option from set by the command line

	$option_output_directory = $configuration->{OUTPUTDIR};

	chomp($option_output_directory);

	print "\tOutput directory is $option_output_directory\n";
    }

    if (defined $configuration->{URL})
    {
	chomp($configuration->{URL});

	print "\tThe link for accessing the content is $configuration->{URL}\n";
    }

    if (defined $configuration->{LOGROTATE})
    {
	chomp($configuration->{LOGROTATE});

	print "\tNumber of logs to rotate $configuration->{LOGROTATE}\n";
    }

    if (defined $configuration->{LOGDIR})
    {
	chomp($configuration->{LOGDIR});

	print "\tDirectory to store past logs is $configuration->{LOGDIR}\n";
    }

    if (defined $configuration->{DOCUMENTROOT})
    {
	chomp($configuration->{DOCUMENTROOT});

	$build_directory = $configuration->{DOCUMENTROOT};

	print "\tThe root directory for all documents is $build_directory\n";
    }

    if (defined $configuration->{HTACCESS})
    {
	chomp($configuration->{HTACCESS});

	$htaccess_file = $configuration->{HTACCESS};

	print "\tThe htaccess file to use is $htaccess_file\n";
    }

    print "Done Parsing $config_file:\n";
}


# rotates logs with the name '$logname'

sub rotate_logs
{
    my $output_dir = $configuration->{OUTPUTDIR};

    my $logname =  $option_output_directory . "/" . $output_filename;

    my $numlogs  = -1;

    if (not defined $configuration->{LOGROTATE})
    {
	# if not rotating logs, delete the log from the last run.

	if (-e $logname)
	{
	    system "rm -f $logname";
	}

	return;
    }
    else
    {
	$numlogs = $configuration->{LOGROTATE};
    }

    my $logdir = $output_dir;

    if (defined $configuration->{LOGDIR})
    {
	$logdir = $configuration->{LOGDIR};

	if(! -d $logdir)
	{
	    mkdir $logdir
	}

	$logdir .= "/";
    }

    # we shift all of our logs if present.
    # Whatever log happens to be the last one should
    # get overwritten with a previous log.

    my $i;

    for ($i = $numlogs - 1 ; $i > -1 ; $i--)
    {
	my $log = $logdir . $logname .'.' . $i;

	if (-e $log)
	{
	    # mv should preserve permissions.

	    my $nextlog = $logdir . $logname . '.' . ($i+1);

	    system "mv -f $log $nextlog";
	}
	else
	{
	    next;
	}
    }

    # after the shift, we should be able to move the
    # first log to slot 0. Now the original slot is open
    # for a log run.

    my $nextlog = $logdir . $logname . '.' . 0;

    system "mv -f $logname $nextlog";

    return;
}


sub index_page_generate
{
    my $index_file = $option_html_output_directory . "/${documentation_set_name}/index.html";

    my $html_document = $index_file;

    open(OUTPUT,">$html_document");

    print OUTPUT "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\n<html>\n  <head>\n    <title>";

    print OUTPUT $html_document . " (http redirect)";

    print OUTPUT "</title>\n  </head>\n  <body><meta http-equiv=\"refresh\" content=\"0;URL=";

    my $redirect_url = "$home_page_document/$home_page_document.html";

    print OUTPUT $redirect_url;

    print OUTPUT "\">\n  </body>\n</html>\n\n";

    close(OUTPUT);
}


sub contents_page_generate
{
    my $contents_file = $option_html_output_directory . "/${documentation_set_name}/contents.html";

#     my $contents_file = $option_html_output_directory . "/html/contents.html";

    open(CONTENTS,">$contents_file") or die "cannot open file for writing: $!";

    my $html_starter = "<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">
<html>
<head>
  <meta
 content=\"text/html; charset=ISO-8859-1\"
 http-equiv=\"content-type\">
  <title>Neurospaces Content Management System</title>
</head>
<body>
For the home page please click <a
 href=\"${home_page_document}/${home_page_document}.html\">here.</a>
<br>
<br>
This is a listing of all published documents in the ${documentation_set_name} documentation. <br>
<br>
<br>
<ul>
";

    print CONTENTS $html_starter;

    #t this needs to be replaced with the same loop as in the main build script.
    #t likely saying that contents generation should be part of the main build script.

    my $documentlist = `${documentation_set_name}-tag-filter published`;

    my $tmp = YAML::Load($documentlist);

    my @published_documents = sort @$tmp;

    foreach (@published_documents)
    {
	my $descriptor_file = $_ . "/descriptor.yml";

	my $descriptor = YAML::LoadFile($descriptor_file);

	my @dirs = split(/\//,$_);

	my $documentname = $dirs[-1];

	print CONTENTS "<li><a href=\"";

	my $document
	    = Neurospaces::Documentation::Document->new
		(
		 {
		  name => $documentname,
		 },
		);

	my $suffix = ".html";

	if ($document->is_pdf())
	{
	    $suffix = ".pdf";
	}

	print CONTENTS $documentname . "/" . $documentname . $suffix;

	print CONTENTS "\">";

	print CONTENTS $descriptor->{'document name'};

	print CONTENTS "</a></li>\n";
    }

    print CONTENTS "</ul>\n</body>\n</html>\n";

    close CONTENTS;

    print "Constructed the contents page\n";
}


#
# This sub routine just copies an .htaccess file to the root web directory.
#
sub copy_htacces_file
{
  my $target_htaccess_file = $option_html_output_directory . "/${documentation_set_name}/.htaccess";

  if(-e $htaccess_file)
  {
    system "cp $htaccess_file $target_htaccess_file";
  }
}



#
# run the main program.
#
main();

